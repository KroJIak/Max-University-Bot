// Получаем базовый URL для MAX API с приоритетом: сначала домен, потом HOST:PORT
// Переменные встраиваются через envsubst во время запуска контейнера
function getMaxApiUrl() {
    // Приоритет 1: Доменный URL из переменной окружения (если задан)
    const maxApiDomainUrl = '${MAX_API_DOMAIN_URL}';
    if (maxApiDomainUrl && maxApiDomainUrl.trim() !== '' && maxApiDomainUrl !== 'undefined') {
        const cleanUrl = maxApiDomainUrl.trim().replace(/\/+$/, '');
        return cleanUrl + '/api/v1';
    }
    
    // Приоритет 2: HOST:PORT из переменных окружения
    const maxApiHost = '${MAX_API_HOST}';
    const maxApiPort = '${MAX_API_PORT}';
    
    // Если HOST = 0.0.0.0, используем текущий хост (для доступа из браузера)
    if (maxApiHost === '0.0.0.0' || maxApiHost === 'localhost' || !maxApiHost || maxApiHost === 'undefined') {
        // Используем текущий хост, но меняем порт на порт API
        const currentHost = window.location.hostname;
        const port = maxApiPort && maxApiPort !== 'undefined' ? maxApiPort : '8003';
        return `http://${currentHost}:${port}/api/v1`;
    }
    
    const port = maxApiPort && maxApiPort !== 'undefined' ? maxApiPort : '8003';
    return `http://${maxApiHost}:${port}/api/v1`;
}

// Получаем fallback URL (для случая, если домен не работает)
function getMaxApiFallbackUrl() {
    const maxApiHost = '${MAX_API_HOST}';
    const maxApiPort = '${MAX_API_PORT}';
    const fallbackHost = (maxApiHost === '0.0.0.0' || !maxApiHost || maxApiHost === 'undefined') 
        ? window.location.hostname 
        : maxApiHost;
    const port = maxApiPort && maxApiPort !== 'undefined' ? maxApiPort : '8003';
    return `http://${fallbackHost}:${port}/api/v1`;
}

const API_BASE_URL = getMaxApiUrl();
const API_FALLBACK_URL = getMaxApiFallbackUrl();

// Функция для выполнения запросов с fallback на HOST:PORT если домен не работает
async function fetchWithFallback(url, options = {}) {
    // Сначала пробуем основной URL
    try {
        const response = await fetch(url, options);
        // Если ответ получен (даже с ошибкой статуса), возвращаем его
        // Но если статус указывает на проблему с доменом (CORS, сеть), пробуем fallback
        if (!response.ok && response.status === 0) {
            // Статус 0 обычно означает ошибку сети/CORS
            throw new Error('Network error or CORS issue');
        }
        return response;
    } catch (error) {
        // Если ошибка сети и мы использовали домен (https или другой хост), пробуем fallback
        const currentUrlIsDomain = url.includes('https://') || 
            (url.startsWith('http://') && !url.includes(window.location.hostname));
        const baseUrlIsDomain = API_BASE_URL.includes('https://') || 
            (API_BASE_URL.startsWith('http://') && !API_BASE_URL.includes(window.location.hostname));
        
        // Если основной URL был доменным и произошла ошибка, пробуем fallback
        if (baseUrlIsDomain && currentUrlIsDomain && API_FALLBACK_URL !== API_BASE_URL) {
            console.warn('Запрос к домену не удался, пробуем локальный URL:', error);
            // Заменяем базовый URL на fallback URL в пути запроса
            const fallbackUrl = url.replace(API_BASE_URL, API_FALLBACK_URL);
            
            try {
                return await fetch(fallbackUrl, options);
            } catch (fallbackError) {
                console.error('Запрос к локальному URL также не удался:', fallbackError);
                throw error; // Возвращаем оригинальную ошибку
            }
        }
        throw error;
    }
}

// Список функций с их описаниями и endpoints для University API, разделенные по категориям
const FEATURES_BY_CATEGORY = {
    'management': [
        {
            id: 'students_login',
            name: 'Логин студентов',
            description: 'Выполнить логин на сайте университета, вернуть cookies',
            defaultEndpoint: '/students/login'
        },
        {
            id: 'students_personal_data',
            name: 'Данные студента',
            description: 'Получить данные студента с lk.chuvsu.ru',
            defaultEndpoint: '/students/personal_data'
        }
    ],
    'services': [
        {
            id: 'students_teachers',
            name: 'Список преподавателей',
            description: 'Получить список всех преподавателей',
            defaultEndpoint: '/students/teachers'
        },
        {
            id: 'students_schedule',
            name: 'Расписание',
            description: 'Получить расписание занятий (текущая или следующая неделя)',
            defaultEndpoint: '/students/schedule'
        },
        {
            id: 'students_contacts',
            name: 'Контакты',
            description: 'Получить контакты деканатов и кафедр',
            defaultEndpoint: '/students/contacts'
        },
        {
            id: 'students_platforms',
            name: 'Веб-платформы',
            description: 'Получить список полезных веб-платформ',
            defaultEndpoint: '/students/platforms'
        }
    ],
    'additional': [
        {
            id: 'students_teacher_info',
            name: 'Информация о преподавателе',
            description: 'Получить информацию о конкретном преподавателе (кафедры, фото)',
            defaultEndpoint: '/students/teacher_info'
        }
    ]
};

// Получить все функции в одном массиве (для обратной совместимости)
const FEATURES = [
    ...FEATURES_BY_CATEGORY.management,
    ...FEATURES_BY_CATEGORY.services,
    ...FEATURES_BY_CATEGORY.additional
];

const UNIVERSITY_STORAGE_KEY = 'selected_university_id';
const AUTH_TOKEN_KEY = 'university_auth_token';
let currentUniversityId = null;

// Функция для получения токена из localStorage
function getAuthToken() {
    return localStorage.getItem(AUTH_TOKEN_KEY);
}

// Функция для выполнения запросов с токеном авторизации
async function fetchWithAuth(url, options = {}) {
    const token = getAuthToken();
    
    // Добавляем токен в заголовки, если он есть
    if (token) {
        if (!options.headers) {
            options.headers = {};
        }
        options.headers['Authorization'] = `Bearer ${token}`;
    }
    
    // Добавляем Content-Type, если его нет и есть тело запроса
    if (options.body && !options.headers['Content-Type']) {
        if (!options.headers) {
            options.headers = {};
        }
        options.headers['Content-Type'] = 'application/json';
    }
    
    try {
        const response = await fetchWithFallback(url, options);
        
        // Если получили 401 (Unauthorized), очищаем токен и редиректим на login
        if (response.status === 401 || response.status === 403) {
            console.error('Ошибка аутентификации:', response.status);
            localStorage.removeItem(AUTH_TOKEN_KEY);
            localStorage.removeItem(UNIVERSITY_STORAGE_KEY);
            window.location.href = 'login.html';
            throw new Error('Требуется повторная аутентификация');
        }
        
        return response;
    } catch (error) {
        // Если ошибка связана с аутентификацией, редиректим на login
        if (error.message && error.message.includes('аутентификац')) {
            localStorage.removeItem(AUTH_TOKEN_KEY);
            localStorage.removeItem(UNIVERSITY_STORAGE_KEY);
            window.location.href = 'login.html';
        }
        throw error;
    }
}
let currentConfig = {
    university_api_base_url: '',
    endpoints: {}
};

// Получение university_id из URL или localStorage
function getUniversityId() {
    // Проверяем, есть ли токен аутентификации
    const token = getAuthToken();
    if (!token) {
        // Если токена нет, перенаправляем на страницу логина
        console.log('Токен аутентификации не найден, перенаправление на login.html');
        window.location.href = 'login.html';
        return null;
    }
    
    // Сначала пробуем получить из URL
    const urlParams = new URLSearchParams(window.location.search);
    const universityIdFromUrl = urlParams.get('university_id');
    
    if (universityIdFromUrl) {
        // Сохраняем в localStorage
        localStorage.setItem(UNIVERSITY_STORAGE_KEY, universityIdFromUrl);
        return parseInt(universityIdFromUrl);
    }
    
    // Если в URL нет, пробуем получить из localStorage
    const universityIdFromStorage = localStorage.getItem(UNIVERSITY_STORAGE_KEY);
    if (universityIdFromStorage) {
        return parseInt(universityIdFromStorage);
    }
    
    // Если нигде нет, перенаправляем на страницу логина
    console.log('University ID не найден, перенаправление на login.html');
    window.location.href = 'login.html';
    return null;
}

// Загрузка информации о университете
async function loadUniversityInfo() {
    if (!currentUniversityId) {
        return;
    }
    
    try {
        const response = await fetchWithFallback(`${API_BASE_URL}/universities/${currentUniversityId}`);
        if (response.ok) {
            const university = await response.json();
            const universityNameEl = document.getElementById('university-name');
            if (universityNameEl) {
                universityNameEl.textContent = `Университет: ${university.name}`;
            }
        }
    } catch (error) {
        console.error('Ошибка загрузки информации о университете:', error);
    }
}

// Инициализация
document.addEventListener('DOMContentLoaded', async () => {
    // Получаем university_id
    currentUniversityId = getUniversityId();
    
    if (!currentUniversityId) {
        return; // Перенаправление на login.html
    }
    
    await loadUniversityInfo();
    await loadConfig();
    renderFeatures();
    setupEventListeners();
    
    // Обработчик кнопки смены университета
    const changeUniversityBtn = document.getElementById('change-university-btn');
    if (changeUniversityBtn) {
        changeUniversityBtn.addEventListener('click', () => {
            // Очищаем токен аутентификации и university_id
            localStorage.removeItem(UNIVERSITY_STORAGE_KEY);
            localStorage.removeItem(AUTH_TOKEN_KEY);
            localStorage.removeItem('university_name');
            console.log('Токен и данные университета очищены, перенаправление на login.html');
            window.location.href = 'login.html';
        });
    }
});

// Загрузка конфигурации
async function loadConfig() {
    if (!currentUniversityId) {
        return;
    }
    
    try {
        const response = await fetchWithAuth(`${API_BASE_URL}/config/university/${currentUniversityId}`);
        if (response.ok) {
            const data = await response.json();
            currentConfig = {
                university_api_base_url: data.university_api_base_url || '',
                endpoints: data.endpoints || {}
            };
            document.getElementById('university-api-url').value = currentConfig.university_api_base_url;
        } else if (response.status === 404) {
            // Конфигурации еще нет, используем значения по умолчанию
            currentConfig = {
                university_api_base_url: '',
                endpoints: {}
            };
        }
    } catch (error) {
        console.error('Ошибка загрузки конфигурации:', error);
        showStatus('Ошибка загрузки конфигурации', 'error');
    }
}

// Сохранение конфигурации
async function saveConfig() {
    if (!currentUniversityId) {
        showStatus('Университет не выбран', 'error');
        return;
    }
    
    const apiUrl = document.getElementById('university-api-url').value.trim();
    
    if (!apiUrl) {
        showStatus('Укажите Base URL University API', 'error');
        return;
    }

    try {
        const response = await fetchWithAuth(`${API_BASE_URL}/config/university`, {
            method: 'PUT',
            body: JSON.stringify({
                university_id: currentUniversityId,
                university_api_base_url: apiUrl,
                endpoints: currentConfig.endpoints
            })
        });

        if (response.ok) {
            currentConfig.university_api_base_url = apiUrl;
            showStatus('Конфигурация успешно сохранена', 'success');
        } else {
            const error = await response.json();
            showStatus(`Ошибка сохранения: ${error.detail || 'Неизвестная ошибка'}`, 'error');
        }
    } catch (error) {
        console.error('Ошибка сохранения конфигурации:', error);
        showStatus('Ошибка сохранения конфигурации', 'error');
    }
}

// Рендеринг списка функций по категориям
function renderFeatures() {
    // Очищаем все секции
    document.getElementById('management-features').innerHTML = '';
    document.getElementById('services-features').innerHTML = '';
    document.getElementById('additional-features').innerHTML = '';

    // Рендерим функции управления
    renderFeatureCategory('management-features', FEATURES_BY_CATEGORY.management);
    
    // Рендерим сервисы
    renderFeatureCategory('services-features', FEATURES_BY_CATEGORY.services);
    
    // Рендерим дополнительный функционал
    renderFeatureCategory('additional-features', FEATURES_BY_CATEGORY.additional);

    // Добавляем обработчики событий для переключателей
    document.querySelectorAll('.switch').forEach(switchEl => {
        switchEl.addEventListener('click', toggleFeature);
    });

    // Добавляем обработчики для полей endpoint
    document.querySelectorAll('.endpoint-input').forEach(input => {
        input.addEventListener('blur', updateEndpoint);
    });
}

// Рендеринг функций в категории
function renderFeatureCategory(containerId, features) {
    const container = document.getElementById(containerId);
    
    features.forEach(feature => {
        // Проверяем старый id students_tech и мигрируем на students_teachers
        let featureId = feature.id;
        if (featureId === 'students_tech' && currentConfig.endpoints['students_tech']) {
            // Мигрируем старый ключ на новый
            currentConfig.endpoints['students_teachers'] = currentConfig.endpoints['students_tech'];
            delete currentConfig.endpoints['students_tech'];
        }
        
        const isEnabled = currentConfig.endpoints[featureId] !== undefined;
        const endpoint = currentConfig.endpoints[featureId] || feature.defaultEndpoint;

        const featureItem = document.createElement('div');
        featureItem.className = 'feature-item';
        featureItem.innerHTML = `
            <div class="feature-header">
                <div class="feature-title">
                    <span>${feature.name}</span>
                </div>
                <div class="switch-container">
                    <span style="font-size: 14px; color: #666;">${isEnabled ? 'Включено' : 'Выключено'}</span>
                    <div class="switch ${isEnabled ? 'active' : ''}" data-feature-id="${featureId}"></div>
                </div>
            </div>
            <div class="feature-description">${feature.description}</div>
            <input 
                type="text" 
                class="endpoint-input" 
                data-feature-id="${featureId}"
                value="${endpoint}"
                placeholder="Endpoint для ${feature.name}"
                ${!isEnabled ? 'disabled' : ''}
            />
        `;

        container.appendChild(featureItem);
    });
}

// Переключение функции
async function toggleFeature(event) {
    const switchEl = event.currentTarget;
    const featureId = switchEl.getAttribute('data-feature-id');
    const isEnabled = switchEl.classList.contains('active');
    const endpointInput = document.querySelector(`.endpoint-input[data-feature-id="${featureId}"]`);

    if (isEnabled) {
        // Выключаем
        switchEl.classList.remove('active');
        endpointInput.disabled = true;
        delete currentConfig.endpoints[featureId];
    } else {
        // Включаем
        switchEl.classList.add('active');
        endpointInput.disabled = false;
        const feature = FEATURES.find(f => f.id === featureId);
        if (!currentConfig.endpoints[featureId]) {
            currentConfig.endpoints[featureId] = feature.defaultEndpoint;
            endpointInput.value = feature.defaultEndpoint;
        }
    }

    // Обновляем текст статуса
    const switchContainer = switchEl.closest('.switch-container');
    const statusText = switchContainer.querySelector('span');
    statusText.textContent = !isEnabled ? 'Включено' : 'Выключено';

    // Сохраняем конфигурацию
    await saveConfig();
}

// Обновление endpoint
async function updateEndpoint(event) {
    const input = event.currentTarget;
    const featureId = input.getAttribute('data-feature-id');
    const endpoint = input.value.trim();

    if (endpoint) {
        currentConfig.endpoints[featureId] = endpoint;
        await saveConfig();
    }
}

// Настройка обработчиков событий
function setupEventListeners() {
    document.getElementById('save-api-url').addEventListener('click', saveConfig);
    
    // Сохранение по Enter
    document.getElementById('university-api-url').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            saveConfig();
        }
    });
}

// Показать статус
function showStatus(message, type = 'info') {
    const statusEl = document.getElementById('status-message');
    statusEl.textContent = message;
    statusEl.className = `status-message ${type}`;
    
    setTimeout(() => {
        statusEl.className = 'status-message';
    }, 5000);
}

